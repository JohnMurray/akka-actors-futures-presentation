<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Akka - Futures &amp; Actors</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<!-- Title -->
				<section data-markdown>
					<script type="text/markdown">
					# Akka - Futures &amp; Actors
					<p>
						<small>Created by 
							<a href="http://johnmurray.io">John Murray</a>
						</small>
					</p>
					</script>
				</section>
				
				<!-- Presentation Overview -->
				<section>
					<section data-markdown>
						<script type="text/markdown">
						## Overview
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Overview - Things Covered

						- Actors
						  - Basic Usage
						- Futures
						  - Basic Usage
						  - Actor Communication
						  - Composition
						- Lab Experiment
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Overview - Things Not Covered

						- Akka
						  - Routers
						  - Schedulers
						  - Remote Communiction
						  - Lots of other stuff
						- Futures
						  - Execution Contexts
						  - Promises
						</script>
					</section>
				</section>
				
				<!-- Actors - Overview -->
				<section>
					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						The actor model in computer science is a mathematical model of concurrent 
						computation that treats "actors" as the universal primitives of concurrent 
						digital computation. 

						<br />

						In response to a message that it receives, an actor can make local decisions, 
						create more actors, send more messages, and determine how to respond to the 
						next message received.

						<br />

						Source: [Wikipedia](https://en.wikipedia.org/wiki/Actor_%28computer_science%29)
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						The primary form of concurrency within Scala. 

						<br />

						Built on asynchronous message passing

						<br />

						Implementation borrowed heavy from actor-based patterns in Erlang.

						<aside class="notes">
							<ol>
								<li><b>Threads</b> present, but not preferred. Mainly for interopability / Actor implementation</li>
								<li><b>Erlang</b> is built for high-availability systems - telecom - rabbitmq</li>
							</ol>
						</aside>
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						Popular&rsquo;ish languages implementing the Actor model

						- Scala (duh)
						- Erlang
						- Elixer
						- D
						- E
						- Io
						- Rust
						- Go
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						Actor frameworks also exist for many popular languages:

						- Java
						- C# / .NET
						- F#
						- Haskell
						- Objective-C
						- C++
						- Clojure
						- Ruby
						- Python
						- C
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						An actor can be thought of as running in a seperate process as they
						share no state with the outside world. 

						<br />

						Typical actor based development is akin to implementing a Service
						Oriented Architecture (SOA) within a single application. 

						<aside class="notes">
						Walk through a demonstration of building a web app with some actors:
							<ol>
								<li>Authentication actor</li>
								<li>DB Service Actor - returns data</li>
								<li>Handler actor - receives incoming request</li>
								<li>etc.</li>
							</ol>
						</aside>
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						All actors belong to an `ActorSystem`. The system contains all actors
						and handles all communication between actors. 

						<aside class="notes">
							Draw a representation of an actor system (big circle with smaller
							circles [actors] inside).
						</aside>
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						Actors can run in the same process, on the same machine (different processes),
						or on different servers (possibly in different data-centers).

						<br />

						Communication is done either by inter-thread communication or over TCP using a 
						custom Akka protocol.

						<aside class="notes">
							<ol>
								<li>
									Edit the previous drawing to show that <b>ActorSystem</b>s on different
									processes communicate to each other (possibly not over a port).
								</li>
								<li>
									Edit the previous drawing to show that the <b>ActorSystem</b> can expose a
									port to handle incoming requests on (Akka Remoting).
								</li>
							</ol>
						</aside>
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						All actors have a Supervisor. The supervisor is responsible for monitoring the
						lifecycle of the Actor. This includes failures / errors and termination.

						<br />

						The Supervisor to any given actor is the Actor that created it. The default
						Actor in Akka is the "Guardian" actor.
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Overview

						Actors can be put behind a router, allowing you to do things like creating a
						pool of workers.

						<br />

						Identical ActorSystems can also be clustered for larger installations
						</script>
					</section>

				</section>

				<!-- Actors - Scala -->
				<section>
					<section data-markdown>
						<script type="text/markdown">
						## Actor - Scala
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Scala

						Hello World Actor

							class HelloActor extends Actor {
								def receive = {
									case msg: String => println(msg)
								}
							}

							// create actor (code omitted)

							helloActor ! "Hello"
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Scala

						Hello World Actor

							class HelloActor extends Actor {
								def receive = {
									case msg: String => println(msg)
								}
							}

							// create actor (code omitted)

							helloActor ! "Hello"
							println(" World")

						<aside class="notes">
							Talk about async-processing
						</aside>
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Scala

						State is self-contained

							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
								}
							}

							// create actor (code omitted)

							incActor ! 3
							incActor ! 4
							incActor ! 5

							println(incActor.count)  # => Compile Time Exception!

						<aside class="notes">
							Talk about how the actor is encapsulated within an Actor
							Ref (briefly).
						</aside>
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Scala

						State is self-contained

							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
									case "count"    => println(this.count)
								}
							}

							// create actor (code omitted)

							incActor ! 3
							incActor ! 4
							incActor ! 5

							incActor ! "count"

						<aside class="notes">
							Talk about how the actor is encapsulated within an Actor
							Ref (briefly).
						</aside>
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Scala

						State is self-contained

							class IncActor extends Actor {
								var count: Int = 0

								def receive = {
									case incBy: Int => this.count += incBy
									case "getCount" => sender ! this.count
								}
							}

							// create actor (code omitted)

							incActor ! 3
							// ...

							Patterns.ask(incActor, "getCount").onComplete {
								count => println(count)
							}

						<aside class="notes">
							Talk about how data received from the actor has to be processed
							asynchronously (callbacks) because actors receive, process, and
							send messages asynchronously.
						</aside>
						</script>
					</section>
				</section>

				<!-- Akka - Java -->
				<section>
					<section data-markdown>
						<script type="text/markdown">
						## Actor - Java
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Java

							public class HelloActor extends UntypedActor {
								@Override
								public void onReceive(Object msg) throws Exception {
									if (msg instanceOf String) {
										System.out.println((String) msg);
									}
								}
							}
							// create actor (code omitted)
							helloActor.tell("Hello", ActorRef.noSender());
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Java

							public class IncActor extends UntypedActor {
								private int count = 0;

								@Override
								public void onReceive(Object msg) throws Exception {
									if (msg instanceOf Integer) {
										this.count += (Integer) msg;
									}
									else if (msg instanceOf String) {
										if ( ((String)msg).equals("getCount") ) {
											getSender().tell(this.count, getSelf());
										}
									}
								}
							}
							// create actor (code omitted)
							incActor.tell(3, ActorRef.noSender());
						</script>
					</section>

					<section data-markdown>
						<script type="text/markdown">
						## Actor - Java

							// continued from previous slide
							Patterns.ask(incActor, "getCount", 1000).onComplete(
								new OnComplete<Object>() {
									public void onComplete(Throwable failure, Object result) {
										if (failure == null) {
											System.out.println(new Integer((int)result).toString());
										}
									}
								},
								system.dispatcher()  // execution context
							);
						</script>
					</section>
				</section>

				<!-- Futures -->
				<section>
					<section data-markdown>
						<script type="text/markdown">
						## Akka - Future
						</script>
					</section>
				</section>


				<!-- Assignment -->
				<section data-markdown>
					<script type="text/markdown">
					## Akka - Lab Time
					</script>
				</section>


				<!-- END -->
				<section>
					<h1>Done</h1>
					<small>go away</small>
					<p>By <a href="http://johnmurray.io">John Murray</a></p>
				</section>


			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
